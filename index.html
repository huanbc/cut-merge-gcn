<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xử Lý Ảnh và Ghép PDF)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script> 
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0/dist/body-pix.min.js"></script>
    
    <style>
        /* Đảm bảo canvas có thể mở rộng */
        #imageCanvas {
            max-width: 100%;
            height: auto;
            border: 2px dashed #3B82F6;
            margin-top: 1rem;
            background-color: #ffffff; /* Nền trắng cho canvas */
            /* Cần thiết lập position: relative để các lớp overlay vẽ đúng */
            position: relative; 
            cursor: default;
            /* Thêm filter CSS để áp dụng hiệu ứng độ sáng/tương phản */
            filter: brightness(100%) contrast(100%); 
        }
        /* Sử dụng font Inter cho thẩm mỹ */
        body {
            font-family: 'Inter', sans-serif;
            /* Thêm ảnh nền phong cảnh Việt Nam */
            background-image: url('https://cdn.pixabay.com/photo/2016/06/15/22/41/vietnam-1459891_1280.jpg');
            background-size: cover; /* Đảm bảo ảnh nền phủ kín trang */
            background-attachment: fixed; /* Giữ ảnh nền cố định khi cuộn */
            background-color: #f7f9fb; /* Màu dự phòng */
            scroll-behavior: smooth; /* Cuộn mượt khi nhấn nút */
        }
    </style>
</head>
<body>

    <div class="container mx-auto p-4 md:p-8 max-w-5xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800">Công Cụ Cắt Ghép Ảnh thành PDF</h1>
            <p class="text-gray-500 mt-2">AI Xử lý ảnh, ghép thành PDF A4 Chuẩn. Tác giả: Lê Minh Huấn CN VPĐKĐĐ 8 -SĐT: 0912041201 </p>
        </header>

        <div class="bg-white/95 p-6 rounded-xl shadow-lg border border-gray-100 mb-6">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">1. Tải và Cắt Ảnh (Chỉ hỗ trợ JPG/PNG/WEBP)</h2>
            
            <input type="file" id="fileInput" accept="image/jpeg, image/png, image/webp" style="display: none;" />
            <button id="uploadButton" class="w-full text-sm file:text-transparent
                file:mr-4 file:py-2 file:px-4 file:text-white
                file:rounded-full file:border-0 file:cursor-pointer
                file:text-sm file:font-bold file:shadow
                bg-yellow-500 hover:bg-yellow-600 transition duration-150 ease-in-out font-bold py-3 px-4 rounded-xl shadow-md text-white">
                Tải Ảnh Lên (Click vào đây)
            </button>
            
            <div id="controls" class="mt-4" style="display:none;">
                
                <div class="flex flex-wrap gap-4 mb-4">
                    <button id="autoCropButton" class="flex-1 min-w-[150px] bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Đề xuất Khung Cắt (90% Ảnh Gốc)
                    </button>
                    <button id="rotateButton" class="flex-1 min-w-[100px] bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Xoay 90°
                    </button>
                    <button id="sharpenButton" class="flex-1 min-w-[100px] bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Làm Nét Ảnh
                    </button>
                    <button id="deskewButton" class="flex-1 min-w-[100px] bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out" disabled>
                        Làm Phẳng (Beta)
                    </button>
                    <button id="removeObjectButton" class="flex-1 min-w-[100px] bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Tách Nền/Giữ Đối Tượng (AI)
                    </button>
                    <button id="resetCropButton" class="flex-1 min-w-[100px] bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Cắt Toàn Bộ Ảnh
                    </button>
                </div>
                
                <div class="p-3 bg-gray-50 rounded-lg mb-4 border border-gray-200">
                    <p class="text-sm font-semibold text-gray-600 mb-2">Chỉnh sửa Thủ công (Xem trước trên Canvas):</p>
                    <div class="flex flex-wrap gap-4 items-center">
                        <label for="brightnessSlider" class="text-sm text-gray-700 min-w-[80px]">Độ Sáng:</label>
                        <input type="range" id="brightnessSlider" min="50" max="150" value="100" class="flex-grow h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                        <span id="brightnessValue" class="text-sm font-mono text-gray-800 w-[40px]">100%</span>

                        <label for="contrastSlider" class="text-sm text-gray-700 min-w-[80px]">Tương Phản:</label>
                        <input type="range" id="contrastSlider" min="50" max="150" value="100" class="flex-grow h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                        <span id="contrastValue" class="text-sm font-mono text-gray-800 w-[40px]">100%</span>
                        
                        <button id="applyColorButton" class="bg-green-500 hover:bg-green-600 text-white text-sm font-bold py-1 px-3 rounded-full shadow transition duration-150 ease-in-out ml-auto">
                            Áp Dụng Vĩnh Viễn
                        </button>
                    </div>
                </div>

                <div class="flex flex-wrap gap-4 mb-4">
                    <button id="savePart1Button" class="flex-1 min-w-[100px] bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Cắt & Lưu Phần 1
                    </button>
                    <button id="savePart2Button" class="flex-1 min-w-[100px] bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Cắt & Lưu Phần 2
                    </button>
                    <button id="savePart3Button" class="flex-1 min-w-[100px] bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Cắt & Lưu Phần 3
                    </button>
                    <button id="savePart4Button" class="flex-1 min-w-[100px] bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Cắt & Lưu Phần 4
                    </button>
                </div>
            </div>

            <div id="messageBox" class="mt-4 p-3 text-sm text-blue-700 bg-blue-100 rounded-lg hidden" role="alert"></div>

            <div class="mt-6 text-center">
                <canvas id="imageCanvas"></canvas>
            </div>

            <p class="text-sm text-gray-400 mt-4 italic text-center">Sử dụng chuột hoặc ngón tay: **Kéo** để di chuyển khung cắt. **Kéo các góc** để thay đổi kích thước.</p>
        </div>
        
        <div class="bg-white/95 p-6 rounded-xl shadow-lg border border-gray-100 mb-6">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">2. Tạo Ảnh Chân Dung ID (Xóa nền AI - 2x3, 3x4, 4x6)</h2>
            <p class="text-sm text-gray-500 mb-4 font-bold text-green-600">ĐÃ KÍCH HOẠT AI: Công cụ sẽ cố gắng **tự động xóa nền** ảnh và thay thế bằng nền màu đã chọn.</p>
            
            <div class="flex flex-wrap gap-3 mb-4 items-center">
                <p class="text-sm font-medium text-gray-700">Chọn Màu Nền:</p>
                <select id="backgroundSelect" class="p-2 border border-gray-300 rounded-lg text-sm">
                    <option value="white">Nền Trắng</option>
                    <option value="blue">Nền Xanh</option>
                </select>
                
                <button id="crop2x3Button" class="flex-1 min-w-[80px] bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out disabled:opacity-50">
                    Cắt & Tải 2x3
                </button>
                <button id="crop3x4Button" class="flex-1 min-w-[80px] bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out disabled:opacity-50">
                    Cắt & Tải 3x4
                </button>
                <button id="crop4x6Button" class="flex-1 min-w-[80px] bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out disabled:opacity-50">
                    Cắt & Tải 4x6
                </button>
            </div>
            
            <div id="portraitMessage" class="mt-4 p-3 text-sm text-blue-700 bg-blue-100 rounded-lg hidden" role="alert"></div>
        </div>

        <div class="bg-white/95 p-6 rounded-xl shadow-lg border border-gray-100 mb-6">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">3. Ghép Ảnh đã cắt và Xuất PDF A4 Ngang (GCN/CCCD)</h2>
            <div id="pdfStatus" class="flex flex-wrap gap-4 mb-4">
                <div id="status1" class="flex-1 min-w-[200px] p-3 rounded-lg border border-red-300 bg-red-50 text-red-700">
                    Phần 1: Chưa Lưu
                </div>
                <div id="status2" class="flex-1 min-w-[200px] p-3 rounded-lg border border-red-300 bg-red-50 text-red-700">
                    Phần 2: Chưa Lưu
                </div>
                <div id="status3" class="flex-1 min-w-[200px] p-3 rounded-lg border border-red-300 bg-red-50 text-red-700">
                    Phần 3: Chưa Lưu
                </div>
                <div id="status4" class="flex-1 min-w-[200px] p-3 rounded-lg border border-red-300 bg-red-50 text-red-700">
                    Phần 4: Chưa Lưu
                </div>
            </div>
            
            <button id="createGcnPdfButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-xl shadow-md transition duration-150 ease-in-out disabled:opacity-50 mb-4" disabled>
                Tạo File PDF A4 Ngang **GCN** (Mỗi Phần/1 Trang)
            </button>
            
            <button id="createCccdPdfButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-xl shadow-md transition duration-150 ease-in-out disabled:opacity-50" disabled>
                Tạo File PDF A4 Ngang **CCCD** (Ghép 2 Mặt/1 Trang Chuẩn)
            </button>
        </div>
        
        <div class="bg-white/95 p-6 rounded-xl shadow-lg border border-gray-100 mt-6">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">4. Ghép nhiều File PDF thành 1</h2>
            <p class="text-sm text-gray-500 mb-4">Chọn **tối thiểu 2** tệp tin PDF để ghép chúng thành một file duy nhất. Tính năng này KHÔNG liên quan đến các ảnh ở phần 1 & 2.</p>
            <input type="file" id="pdfFileInput" accept="application/pdf" multiple class="w-full text-sm file:text-transparent
                file:mr-4 file:py-2 file:px-4 file:text-white
                file:rounded-full file:border-0 file:cursor-pointer
                file:text-sm file:font-bold file:shadow
                file:bg-red-500 hover:file:bg-red-600 transition duration-150 ease-in-out"
            />
            <button id="mergePdfButton" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-xl shadow-md transition duration-150 ease-in-out disabled:opacity-50 mt-4" disabled>
                Ghép N (≥ 2) File PDF Đã Chọn
            </button>
            <div id="pdfMergeMessage" class="mt-4 p-3 text-sm text-blue-700 bg-blue-100 rounded-lg hidden" role="alert"></div>
        </div>
        
    </div>

    <script>
        // --- CHỐNG XEM MÃ NGUỒN (OBFUSCATION & INTERACTION PREVENTION) ---
        document.addEventListener('contextmenu', function(e) { e.preventDefault(); console.warn("%cCẢNH BÁO: MÃ NGUỒN CÓ THỂ CHỨA THÔNG TIN ĐỘC QUYỀN. VUI LÒNG KHÔNG SAO CHÉP. Created by huanbc.", "color: red; font-size: 16px; font-weight: bold;"); });
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F12') { e.preventDefault(); console.warn("%cCẢNH BÁO: Đã vô hiệu hóa phím tắt Developer Tools (F12).", "color: red; font-size: 16px; font-weight: bold;"); }
            if ((e.ctrlKey || e.metaKey) && (e.shiftKey) && (e.key === 'I' || e.key === 'J' || e.key === 'C')) { e.preventDefault(); console.warn("%cCẢNH BÁO: Đã vô hiệu hóa phím tắt Developer Tools (Ctrl+Shift+I/J/C).", "color: red; font-size: 16px; font-weight: bold;"); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'U') { e.preventDefault(); console.warn("%cCẢNH BÁO: Đã vô hiệu hóa phím tắt View Page Source (Ctrl+U).", "color: red; font-size: 16px; font-weight: bold;"); }
        });

        // Khai báo các biến toàn cục (CẮT ẢNH)
        const fileInput = document.getElementById('fileInput');
        const uploadButton = document.getElementById('uploadButton'); 
        const rotateButton = document.getElementById('rotateButton');
        const autoCropButton = document.getElementById('autoCropButton');
        const resetCropButton = document.getElementById('resetCropButton');
        const sharpenButton = document.getElementById('sharpenButton'); 
        const deskewButton = document.getElementById('deskewButton');   
        const removeObjectButton = document.getElementById('removeObjectButton'); 
        const savePart1Button = document.getElementById('savePart1Button');
        const savePart2Button = document.getElementById('savePart2Button');
        const savePart3Button = document.getElementById('savePart3Button');
        const savePart4Button = document.getElementById('savePart4Button');
        
        // Điều khiển màu sắc
        const brightnessSlider = document.getElementById('brightnessSlider');
        const brightnessValue = document.getElementById('brightnessValue');
        const contrastSlider = document.getElementById('contrastSlider');
        const contrastValue = document.getElementById('contrastValue');
        const applyColorButton = document.getElementById('applyColorButton'); 

        // Tạo ảnh ID
        const crop2x3Button = document.getElementById('crop2x3Button');
        const crop3x4Button = document.getElementById('crop3x4Button');
        const crop4x6Button = document.getElementById('crop4x6Button');
        const backgroundSelect = document.getElementById('backgroundSelect');
        const portraitMessage = document.getElementById('portraitMessage');


        // Thay thế createPdfButton bằng 2 nút mới
        const createGcnPdfButton = document.getElementById('createGcnPdfButton');
        const createCccdPdfButton = document.getElementById('createCccdPdfButton');
        
        const controls = document.getElementById('controls');
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const status1 = document.getElementById('status1');
        const status2 = document.getElementById('status2');
        const status3 = document.getElementById('status3');
        const status4 = document.getElementById('status4');
        
        let originalImage = null;       
        let rotationAngle = 0;          
        let croppedImage1 = null; 
        let croppedImage2 = null;  
        let croppedImage3 = null;  
        let croppedImage4 = null;  
        
        // AI Model State
        let bodyPixNet = null; // MỚI: Biến lưu trữ mô hình BodyPix
        let isModelLoading = false;
        const modelLoadMessage = 'Đang tải mô hình AI... Vui lòng chờ.';

        // Lưu trữ giá trị filter hiện tại
        let currentBrightness = 100;
        let currentContrast = 100;

        let cropBox = { x: 0, y: 0, width: 0, height: 0 };
        const HANDLE_SIZE = 15; 
        let isDragging = false;
        let dragHandle = null; 
        let startX, startY; 
        let cropStart;      

        // Khai báo các biến toàn cục (GHÉP PDF)
        const pdfFileInput = document.getElementById('pdfFileInput');
        const mergePdfButton = document.getElementById('mergePdfButton');
        const pdfMergeMessage = document.getElementById('pdfMergeMessage'); 


        // --- HÀM HỖ TRỢ CHUNG (CẮT ẢNH) ---

        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.className = 'mt-4 p-3 text-sm rounded-lg';
            messageBox.classList.remove('hidden');

            switch (type) {
                case 'error':
                    messageBox.classList.add('text-red-700', 'bg-red-100', 'border-red-300');
                    break;
                case 'success':
                    messageBox.classList.add('text-green-700', 'bg-green-100', 'border-green-300');
                    break;
                case 'info':
                default:
                    messageBox.classList.add('text-blue-700', 'bg-blue-100', 'border-blue-300');
                    break;
            }
        }
        
        function updateStatus() {
            const statuses = [
                { index: 1, element: status1, image: croppedImage1 },
                { index: 2, element: status2, image: croppedImage2 },
                { index: 3, element: status3, image: croppedImage3 },
                { index: 4, element: status4, image: croppedImage4 },
            ];
            let gcnReady = false;
            let cccdReady = false;

            statuses.forEach(s => {
                if (s.image) {
                    s.element.textContent = `Phần ${s.index}: Đã Lưu`;
                    s.element.className = 'flex-1 min-w-[200px] p-3 rounded-lg border border-green-300 bg-green-50 text-green-700';
                    gcnReady = true; // Chỉ cần 1 phần là GCN đã sẵn sàng
                } else {
                    s.element.textContent = `Phần ${s.index}: Chưa Lưu`;
                    s.element.className = 'flex-1 min-w-[200px] p-3 rounded-lg border border-red-300 bg-red-50 text-red-700';
                }
            });
            
            // CCCD chỉ sẵn sàng nếu Phần 1 VÀ Phần 2 đã được lưu
            if (croppedImage1 && croppedImage2) {
                cccdReady = true;
            }

            createGcnPdfButton.disabled = !gcnReady;
            createCccdPdfButton.disabled = !cccdReady;
            
            // Bật/tắt nút tạo ảnh ID
            const isImageLoaded = originalImage !== null;
            const isModelReady = bodyPixNet !== null;

            crop2x3Button.disabled = !isImageLoaded || !isModelReady || isModelLoading;
            crop3x4Button.disabled = !isImageLoaded || !isModelReady || isModelLoading;
            crop4x6Button.disabled = !isImageLoaded || !isModelReady || isModelLoading;
        }
        
        // --- HÀM HỖ TRỢ CHUNG (GHÉP PDF) ---
        function showMergeMessage(message, type = 'info') {
            pdfMergeMessage.textContent = message;
            pdfMergeMessage.className = 'mt-4 p-3 text-sm rounded-lg';
            pdfMergeMessage.classList.remove('hidden');

            switch (type) {
                case 'error':
                    pdfMergeMessage.classList.add('text-red-700', 'bg-red-100', 'border-red-300');
                    break;
                case 'success':
                    pdfMergeMessage.classList.add('text-green-700', 'bg-green-100', 'border-green-300');
                    break;
                case 'info':
                default:
                    pdfMergeMessage.classList.add('text-blue-700', 'bg-blue-100', 'border-blue-300');
                    break;
            }
        }
        
        function showPortraitMessage(message, type = 'info') {
            portraitMessage.textContent = message;
            portraitMessage.className = 'mt-4 p-3 text-sm rounded-lg';
            portraitMessage.classList.remove('hidden');

            switch (type) {
                case 'error':
                    portraitMessage.classList.add('text-red-700', 'bg-red-100', 'border-red-300');
                    break;
                case 'success':
                    portraitMessage.classList.add('text-green-700', 'bg-green-100', 'border-green-300');
                    break;
                case 'info':
                default:
                    portraitMessage.classList.add('text-blue-700', 'bg-blue-100', 'border-blue-300');
                    break;
            }
        }

        // --- HÀM XỬ LÝ ẢNH & CANVAS ---

        function drawImage() {
            if (!originalImage) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const rotation = rotationAngle % 360;
            const isRotated = rotation === 90 || rotation === 270;

            const canvasWidth = isRotated ? originalImage.height : originalImage.width;
            const canvasHeight = isRotated ? originalImage.width : originalImage.height;

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // Vẽ ảnh gốc (có thể là PNG trong suốt)
            ctx.save();
            ctx.translate(canvasWidth / 2, canvasHeight / 2);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);
            ctx.restore();

            drawCropOverlay(canvasWidth, canvasHeight);
        }

        function drawCropOverlay(currentCanvasWidth, currentCanvasHeight) {
            const { x, y, width, height } = cropBox;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            
            ctx.fillRect(0, 0, currentCanvasWidth, y);
            ctx.fillRect(0, y + height, currentCanvasWidth, currentCanvasHeight - (y + height));
            ctx.fillRect(0, y, x, height);
            ctx.fillRect(x + width, y, currentCanvasWidth - (x + width), height);

            ctx.strokeStyle = '#22C55E'; 
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]); 
            ctx.strokeRect(x, y, width, height);
            ctx.setLineDash([]); 

            ctx.fillStyle = '#22C55E';
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;

            const handles = [
                { x: x, y: y, cursor: 'nwse-resize' },                   
                { x: x + width, y: y, cursor: 'nesw-resize' },           
                { x: x, y: y + height, cursor: 'nesw-resize' },          
                { x: x + width, y: y + height, cursor: 'nwse-resize' }   
            ];

            handles.forEach(h => {
                ctx.beginPath();
                ctx.arc(h.x, h.y, HANDLE_SIZE / 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            });
        }
        
        function cropImage() {
            if (!originalImage || cropBox.width <= 0 || cropBox.height <= 0) return null;

            const sourceX = cropBox.x;
            const sourceY = cropBox.y;
            const cropWidth = cropBox.width;
            const cropHeight = cropBox.height;
            
            const rotation = rotationAngle % 360;
            const isRotated = rotation === 90 || rotation === 270;
            const rotatedWidth = isRotated ? originalImage.height : originalImage.width;
            const rotatedHeight = isRotated ? originalImage.width : originalImage.height;

            const finalCanvas = document.createElement('canvas');
            const finalCtx = finalCanvas.getContext('2d');
            finalCanvas.width = cropWidth;
            finalCanvas.height = cropHeight;

            try {
                // Canvas phụ để áp dụng CSS Filter và xoay
                const filterCanvas = document.createElement('canvas');
                const filterCtx = filterCanvas.getContext('2d');
                filterCanvas.width = rotatedWidth;
                filterCanvas.height = rotatedHeight;
                filterCanvas.style.filter = `brightness(${currentBrightness}%) contrast(${currentContrast}%)`;

                // Vẽ ảnh đã xoay
                filterCtx.save();
                filterCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
                filterCtx.rotate(rotation * Math.PI / 180);
                filterCtx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);
                filterCtx.restore();

                // Lấy dữ liệu ảnh đã lọc và xoay
                const filteredImageData = filterCtx.getImageData(sourceX, sourceY, cropWidth, cropHeight);
                
                // Cắt
                finalCtx.putImageData(filteredImageData, 0, 0);
            } catch (error) {
                console.error("Lỗi khi lấy/đặt dữ liệu ảnh:", error);
                return null;
            }
            
            // Luôn xuất JPEG cho các phần cắt (Part 1, 2, 3, 4) và GCN/CCCD PDF
            // *LƯU Ý: Nếu ảnh gốc có độ trong suốt (sau khi dùng Tách Nền AI), độ trong suốt sẽ bị mất
            // và vùng trong suốt sẽ trở thành màu đen hoặc màu nền của canvas*
            return finalCanvas.toDataURL('image/jpeg', 0.95);
        }

        // --- HÀM LÀM NÉT ẢNH (SHARPEN) ---
        
        // Hàm tiện ích: Áp dụng bộ lọc Convolution (Giữ nguyên)
        function applyConvolutionFilter(pixels, weights) {
            const side = Math.round(Math.sqrt(weights.length));
            const halfSide = Math.floor(side / 2);
            const src = pixels.data;
            const sw = pixels.width;
            const sh = pixels.height;
            const output = ctx.createImageData(sw, sh);
            const dst = output.data;
            const alphaFac = 1;

            for (let y = halfSide; y < sh - halfSide; y++) {
                for (let x = halfSide; x < sw - halfSide; x++) {
                    const dstIndex = (y * sw + x) * 4;
                    let r = 0, g = 0, b = 0;

                    for (let cy = 0; cy < side; cy++) {
                        for (let cx = 0; cx < side; cx++) {
                            const scx = x + cx - halfSide;
                            const scy = y + cy - halfSide;
                            const srcIndex = (scy * sw + scx) * 4;
                            
                            const weight = weights[cy * side + cx];
                            
                            r += src[srcIndex] * weight;
                            g += src[srcIndex + 1] * weight;
                            b += src[srcIndex + 2] * weight;
                        }
                    }

                    dst[dstIndex] = Math.min(255, Math.max(0, r));
                    dst[dstIndex + 1] = Math.min(255, Math.max(0, g));
                    dst[dstIndex + 2] = Math.min(255, Math.max(0, b));
                    dst[dstIndex + 3] = src[dstIndex + 3] * alphaFac;
                }
            }
            return output;
        }

        // Hàm xử lý: Làm nét ảnh (Giữ nguyên)
        function sharpenImage() {
            if (!originalImage) { showMessage('Vui lòng tải ảnh lên trước.', 'error'); return; }

            try {
                showMessage('Đang xử lý làm nét ảnh... Vui lòng chờ.', 'info');

                const rotation = rotationAngle % 360;
                const isRotated = rotation === 90 || rotation === 270;
                const rotatedWidth = isRotated ? originalImage.height : originalImage.width;
                const rotatedHeight = isRotated ? originalImage.width : originalImage.height;

                // Canvas phụ để áp dụng CSS Filter và xoay
                const filterCanvas = document.createElement('canvas');
                const filterCtx = filterCanvas.getContext('2d');
                filterCanvas.width = rotatedWidth;
                filterCanvas.height = rotatedHeight;
                filterCanvas.style.filter = `brightness(${currentBrightness}%) contrast(${currentContrast}%)`;
                
                filterCtx.save();
                filterCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
                filterCtx.rotate(rotation * Math.PI / 180);
                filterCtx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);
                filterCtx.restore();

                // Lấy dữ liệu pixel đã có filter/rotation
                const imageData = filterCtx.getImageData(0, 0, filterCanvas.width, filterCanvas.height);
                
                // Định nghĩa Kernel Làm Nét (Sharpening Kernel)
                const sharpenWeights = [ 0, -1, 0, -1, 5, -1, 0, -1, 0 ];
                
                // Áp dụng bộ lọc
                const sharpenedData = applyConvolutionFilter(imageData, sharpenWeights);
                
                // Ghi dữ liệu pixel đã xử lý trở lại canvas chính (xóa filter CSS)
                canvas.width = rotatedWidth;
                canvas.height = rotatedHeight;
                canvas.style.filter = 'brightness(100%) contrast(100%)'; 
                ctx.putImageData(sharpenedData, 0, 0);

                // Cập nhật originalImage để lưu trữ trạng thái mới của ảnh
                const newImage = new Image();
                newImage.onload = () => {
                    originalImage = newImage;
                    
                    // Reset filter sau khi áp dụng vĩnh viễn
                    currentBrightness = 100; 
                    currentContrast = 100;
                    brightnessSlider.value = 100;
                    contrastSlider.value = 100;
                    brightnessValue.textContent = '100%';
                    contrastValue.textContent = '100%';
                    
                    rotationAngle = 0; 
                    initCropBox();
                    drawImage(); 
                    showMessage('Đã áp dụng bộ lọc Làm Nét Ảnh thành công! Độ sáng/tương phản đã được đặt lại 100%.', 'success');
                };
                newImage.src = canvas.toDataURL('image/png'); // Dùng PNG để giữ alpha channel nếu có
                
            } catch (error) {
                console.error("LỖI KHI LÀM NÉT ẢNH:", error);
                showMessage(`LỖI: Không thể làm nét ảnh. Chi tiết lỗi: ${error.message}.`, 'error');
            }
        }
        
        // --- HÀM TẢI MÔ HÌNH AI (MỚI) ---
        async function loadBodyPixModel() {
            if (bodyPixNet === null && !isModelLoading) {
                isModelLoading = true;
                showPortraitMessage(modelLoadMessage, 'info');
                try {
                    bodyPixNet = await bodyPix.load({
                        architecture: 'MobileNetV1',
                        outputStride: 16,
                        multiplier: 0.75,
                        quantBytes: 2
                    });
                    showPortraitMessage('Đã tải mô hình AI thành công! Sẵn sàng xóa nền.', 'success');
                } catch (error) {
                    console.error("LỖI KHI TẢI MÔ HÌNH BODYPIX:", error);
                    showPortraitMessage('LỖI: Không thể tải mô hình AI BodyPix. Tính năng AI sẽ không hoạt động.', 'error');
                } finally {
                    isModelLoading = false;
                    updateStatus();
                }
            } else if (bodyPixNet) {
                showPortraitMessage('Mô hình AI đã sẵn sàng.', 'success');
            }
        }

        // --- HÀM TÁCH NỀN/GIỮ ĐỐI TƯỢNG (AI) (MỚI) ---
        async function segmentAndKeepSelected() {
            if (!originalImage) { showMessage('Vui lòng tải ảnh lên trước.', 'error'); return; }
            if (!bodyPixNet) { showMessage('Mô hình AI đang tải hoặc bị lỗi. Vui lòng chờ.', 'error'); return; }

            showMessage('Đang xử lý AI: Tách nền ảnh thành trong suốt. Quá trình này mất vài giây.', 'info');

            try {
                const rotation = rotationAngle % 360;
                const isRotated = rotation === 90 || rotation === 270;
                const rotatedWidth = isRotated ? originalImage.height : originalImage.width;
                const rotatedHeight = isRotated ? originalImage.width : originalImage.height;

                // 1. Tạo Canvas phụ chứa ảnh đã xoay/filter
                const filterCanvas = document.createElement('canvas');
                const filterCtx = filterCanvas.getContext('2d');
                filterCanvas.width = rotatedWidth;
                filterCanvas.height = rotatedHeight;
                filterCanvas.style.filter = `brightness(${currentBrightness}%) contrast(${currentContrast}%)`;
                
                filterCtx.save();
                filterCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
                filterCtx.rotate(rotation * Math.PI / 180);
                filterCtx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);
                filterCtx.restore();

                // 2. Chạy segmentation
                const segmentation = await bodyPixNet.segmentMultiPerson(filterCanvas, {
                    flipHorizontal: false,
                    internalResolution: 'medium',
                    segmentationThreshold: 0.7,
                    maxDetections: 10, 
                    scoreThreshold: 0.5,
                    maskBlurAmount: 3 
                });

                if (!segmentation || segmentation.length === 0) {
                    showMessage('AI không thể phát hiện bất kỳ đối tượng con người nào trong ảnh. Không thể tách nền.', 'error');
                    return;
                }

                // 3. Tạo Canvas đích để vẽ kết quả (trong suốt)
                const segmentedCanvas = document.createElement('canvas');
                const segmentedCtx = segmentedCanvas.getContext('2d');
                segmentedCanvas.width = rotatedWidth;
                segmentedCanvas.height = rotatedHeight;
                
                // Cần vẽ lại ảnh gốc đã filter/xoay lên segmentedCanvas
                segmentedCtx.drawImage(filterCanvas, 0, 0);

                // 4. Áp dụng mask: làm cho mọi pixel KHÔNG PHẢI người trở nên trong suốt.
                // Màu background: trong suốt (r: 0, g: 0, b: 0, a: 0)
                const backgroundGray = { r: 0, g: 0, b: 0, a: 0 }; 
                // Màu foreground: không quan trọng, nhưng alpha phải là 255 (r: 0, g: 0, b: 0, a: 255)
                const foregroundColor = { r: 0, g: 0, b: 0, a: 255 };
                
                // Tạo mask data
                const mask = bodyPix.toMask(segmentation, foregroundColor, backgroundGray, false);

                // Chuyển đổi dữ liệu mask thành dữ liệu alpha trên segmentedCanvas
                const imageData = segmentedCtx.getImageData(0, 0, segmentedCanvas.width, segmentedCanvas.height);
                const data = imageData.data;
                const maskData = mask.data;

                for (let i = 0; i < maskData.length; i += 4) {
                    // Nếu maskData tại kênh R, G, B là 0 VÀ alpha là 0 (tức là BG - trong suốt)
                    // thì đặt alpha của imageData về 0
                    if (maskData[i + 3] === 0) {
                        data[i + 3] = 0; // Kênh Alpha
                    }
                }
                segmentedCtx.putImageData(imageData, 0, 0);

                // 5. Cập nhật originalImage
                const newImage = new Image();
                newImage.onload = () => {
                    originalImage = newImage;
                    rotationAngle = 0; 
                    initCropBox();
                    drawImage(); 
                    showMessage('Đã áp dụng AI: Tách nền thành công (nền trong suốt). Sử dụng khung cắt để giữ lại đối tượng mong muốn.', 'success');
                };
                // PHẢI DÙNG PNG để giữ alpha channel (độ trong suốt)
                newImage.src = segmentedCanvas.toDataURL('image/png'); 
                
                // Reset color filters sau khi áp dụng segmentation
                currentBrightness = 100;
                currentContrast = 100;
                brightnessSlider.value = 100;
                contrastSlider.value = 100;
                canvas.style.filter = 'brightness(100%) contrast(100%)';
                brightnessValue.textContent = '100%';
                contrastValue.textContent = '100%';

            } catch (error) {
                console.error("LỖI KHI TÁCH NỀN (XÓA ĐỐI TƯỢNG):", error);
                showMessage(`LỖI: Không thể tách nền. Chi tiết lỗi: ${error.message}. Vui lòng kiểm tra console (F12).`, 'error');
            }
        }
        
        // --- HÀM TẠO ẢNH ID (ĐÃ CẬP NHẬT SEGMENTATION) ---
        async function createIdPortrait(ratioW, ratioH) {
            if (!originalImage) { showPortraitMessage('Vui lòng tải ảnh lên trước.', 'error'); return; }
            if (!bodyPixNet) { showPortraitMessage('Mô hình AI đang tải hoặc bị lỗi. Vui lòng chờ.', 'error'); return; }

            try {
                const background = backgroundSelect.value;
                const backgroundColor = background === 'blue' ? '#0070c0' : '#FFFFFF';
                const finalWidthMM = ratioW;
                const finalHeightMM = ratioH;
                const scaleFactor = 10; 
                const outputWidthPx = finalWidthMM * scaleFactor;
                const outputHeightPx = finalHeightMM * scaleFactor;
                
                showPortraitMessage('Đang xử lý AI: Xóa nền ảnh và cắt theo khung... Quá trình này mất vài giây.', 'info');

                // BƯỚC 1: Xóa nền trên ảnh gốc
                const segmentation = await bodyPixNet.segmentPerson(originalImage, {
                    flipHorizontal: false,
                    internalResolution: 'medium',
                    segmentationThreshold: 0.7,
                    maxDetections: 1,
                    scoreThreshold: 0.5,
                    maskBlurAmount: 3 
                });

                // Xử lý khi AI không phát hiện người (hoặc lỗi)
                if (!segmentation || segmentation.allContours.length === 0) {
                     showPortraitMessage('AI không thể phát hiện đối tượng con người trong ảnh. Đang sử dụng ảnh đã cắt (nền gốc).', 'error');
                     const croppedDataUrl = cropImage(); 
                     if (!croppedDataUrl) return;
                     await processFinalPortrait(croppedDataUrl, background, finalWidthMM, finalHeightMM, false);
                     return;
                }
                
                // Tạo Canvas phụ để vẽ ảnh đã xoay/filter
                const rotation = rotationAngle % 360;
                const isRotated = rotation === 90 || rotation === 270;
                const rotatedWidth = isRotated ? originalImage.height : originalImage.width;
                const rotatedHeight = isRotated ? originalImage.width : originalImage.height;
                
                const filterCanvas = document.createElement('canvas');
                const filterCtx = filterCanvas.getContext('2d');
                filterCanvas.width = rotatedWidth;
                filterCanvas.height = rotatedHeight;
                filterCanvas.style.filter = `brightness(${currentBrightness}%) contrast(${currentContrast}%)`;

                filterCtx.save();
                filterCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
                filterCtx.rotate(rotation * Math.PI / 180);
                filterCtx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);
                filterCtx.restore();
                
                // Lấy mask (mặt nạ)
                const backgroundGray = { r: 0, g: 0, b: 0, a: 0 }; // Alpha = 0 để làm trong suốt
                const foregroundColor = { r: 0, g: 0, b: 0, a: 255 };
                const mask = bodyPix.toMask(segmentation, foregroundColor, backgroundGray, false);

                // Tạo Canvas đích để vẽ mask lên ảnh đã filter/xoay
                const segmentedCanvas = document.createElement('canvas');
                const segmentedCtx = segmentedCanvas.getContext('2d');
                segmentedCanvas.width = rotatedWidth;
                segmentedCanvas.height = rotatedHeight;
                
                // BƯỚC 2: Áp dụng mask lên ảnh đã filter/xoay
                bodyPix.drawMask(
                    segmentedCanvas, // Canvas đích
                    filterCanvas,    // Ảnh nguồn đã filter/xoay
                    mask,            // Mask đã tạo
                    1.0,             
                    0,               
                    true             // Chỉ vẽ phần foreground (người)
                );

                // BƯỚC 3: Cắt ảnh đã xóa nền theo khung cắt hiện tại
                const croppedSegmentedCanvas = document.createElement('canvas');
                const croppedSegmentedCtx = croppedSegmentedCanvas.getContext('2d');
                croppedSegmentedCanvas.width = cropBox.width;
                croppedSegmentedCanvas.height = cropBox.height;

                try {
                    // Cắt theo cropBox hiện tại
                    const segmentedCroppedImageData = segmentedCtx.getImageData(cropBox.x, cropBox.y, cropBox.width, cropBox.height);
                    croppedSegmentedCtx.putImageData(segmentedCroppedImageData, 0, 0);
                } catch (error) {
                    console.error("Lỗi khi lấy/đặt dữ liệu ảnh sau segment:", error);
                    showPortraitMessage('Lỗi hệ thống khi cắt ảnh đã xóa nền.', 'error');
                    return;
                }
                const croppedSegmentedDataUrl = croppedSegmentedCanvas.toDataURL('image/png');


                // BƯỚC 4: Vẽ lên Canvas đích với nền màu và tải xuống
                await processFinalPortrait(croppedSegmentedDataUrl, background, finalWidthMM, finalHeightMM, true);

            } catch (error) {
                console.error("LỖI KHI TẠO ẢNH ID (FINAL):", error);
                showPortraitMessage(`LỖI: Không thể tạo ảnh chân dung AI. Chi tiết lỗi: ${error.message}. Vui lòng thử lại.`, 'error');
            }
        }
        
        // --- HÀM XỬ LÝ VẼ VÀ TẢI XUỐNG CUỐI CÙNG (Cập nhật để xử lý JPEG/PNG) ---
        async function processFinalPortrait(croppedDataUrl, background, finalWidthMM, finalHeightMM, isSegmented) {
            const backgroundColor = background === 'blue' ? '#0070c0' : '#FFFFFF';
            const scaleFactor = 10; 
            const outputWidthPx = finalWidthMM * scaleFactor;
            const outputHeightPx = finalHeightMM * scaleFactor;

            const finalCanvas = document.createElement('canvas');
            const finalCtx = finalCanvas.getContext('2d');
            finalCanvas.width = outputWidthPx;
            finalCanvas.height = outputHeightPx;

            // 1. Vẽ nền màu (Xanh/Trắng)
            finalCtx.fillStyle = backgroundColor;
            finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);

            // 2. Vẽ ảnh đã cắt lên trên nền
            const finalImg = new Image();
            finalImg.onload = () => {
                // Fit ảnh người đã cắt vào khung nền ID
                let imageW = outputWidthPx;
                let imageH = imageW / (finalImg.width / finalImg.height); 
                const startX = 0;
                const startY = (outputHeightPx - imageH) / 2; 

                // Nếu ảnh đã được segment (PNG có alpha), nó sẽ tự động hòa vào nền màu
                finalCtx.drawImage(finalImg, startX, startY, imageW, imageH);

                // 3. Tải xuống
                const url = finalCanvas.toDataURL('image/jpeg', 0.98);
                const a = document.createElement('a');
                a.href = url;
                const fileType = isSegmented ? "AI_XoaNen" : "NenGoc";
                a.download = `Anh_ID_${fileType}_${finalWidthMM}x${finalHeightMM}mm_${background}_${Date.now()}.jpeg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                showPortraitMessage(`Đã tạo và tải xuống ảnh chân dung ${finalWidthMM}x${finalHeightMM}mm nền ${background} (${fileType}) thành công!`, 'success');
            };
            finalImg.src = croppedDataUrl;
        }

        
        // --- HÀM TẠO PDF (Giữ nguyên) ---
        
        /**
         * Chế độ GCN: Xuất mỗi ảnh đã cắt ra một trang PDF A4 Ngang riêng biệt, co giãn để vừa chiều rộng.
         */
        function createGcnPdfFromMultipleImages() {
            const imagesData = [croppedImage1, croppedImage2, croppedImage3, croppedImage4];
            const images = imagesData.filter(img => img !== null);
            
            if (images.length === 0) {
                showMessage('Vui lòng cắt và lưu ít nhất một Phần ảnh trước khi tạo PDF.', 'error');
                return;
            }
            
            try {
                // Khởi tạo jsPDF với kích thước A4 (Landscape - Ngang, đơn vị mm)
                const doc = new window.jspdf.jsPDF('l', 'mm', 'a4');
                
                const a4Width = 297; // Chiều rộng A4 Ngang
                const a4Height = 210; // Chiều cao A4 Ngang
                const margin = 10;
                const usableWidth = a4Width - 2 * margin; 
                
                // Lặp qua từng ảnh đã cắt
                images.forEach((imgDataUrl, index) => {
                    // Thêm trang mới TỪ trang thứ hai trở đi
                    if (index > 0) {
                        doc.addPage();
                    }
                    
                    const img = document.createElement('img');
                    img.src = imgDataUrl;
                    
                    const imgWidthPx = img.width || 1000; 
                    const imgHeightPx = img.height || 600; 
                    
                    const aspectRatio = imgWidthPx / imgHeightPx;
                    
                    const imageWidthMM = usableWidth; 
                    const imageHeightMM = imageWidthMM / aspectRatio;

                    // Căn giữa theo chiều cao
                    const startY = (a4Height - imageHeightMM) / 2;

                    doc.addImage(imgDataUrl, 'JPEG', margin, startY, imageWidthMM, imageHeightMM);
                });

                const signatureText = "][";
                doc.setFont('Times', 'normal'); 
                doc.setFontSize(9); 
                const signatureMargin = 10;
                const signatureX = a4Width - signatureMargin; 
                const signatureY = a4Height - signatureMargin; 

                doc.setPage(doc.internal.pages.length);
                doc.text(signatureText, signatureX, signatureY, { align: 'right' });


                const pdfBlob = doc.output('blob');
                const url = URL.createObjectURL(pdfBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `GCN_MoiPhan1Trang_A4Ngang_${Date.now()}.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); 

                showMessage(`Đã tạo file PDF A4 Ngang thành công! Gồm ${images.length} trang.`, 'success');

            } catch (error) {
                console.error("LỖI KHI XUẤT PDF GCN:", error);
                showMessage(`LỖI: Không thể tạo file PDF GCN. Chi tiết lỗi: ${error.message}. Vui lòng kiểm tra console (F12) hoặc thử lại.`, 'error');
            }
        }

        /**
         * Chế độ CCCD: Ghép ảnh Phần 1 & Phần 2 vào 1 trang PDF A4 Ngang với kích thước chuẩn.
         */
        function createCccdPdfFromTwoImages() {
            if (!croppedImage1 || !croppedImage2) {
                showMessage('Vui lòng cắt và lưu cả Phần 1 và Phần 2 để ghép CCCD (2 Mặt).', 'error');
                return;
            }
            
            try {
                // Khởi tạo jsPDF với kích thước A4 (Landscape - Ngang, đơn vị mm)
                const doc = new window.jspdf.jsPDF('l', 'mm', 'a4');
                
                const a4Width = 297; // Chiều rộng A4 Ngang
                const a4Height = 210; // Chiều cao A4 Ngang
                // Kích thước CCCD chuẩn (mm): 87 x 58
                const cardWidthMM = 87;
                const cardHeightMM = 58;

                // Tính toán vị trí ảnh (Căn giữa ngang)
                const marginX = (a4Width - cardWidthMM) / 2; // 105 mm
                const startY = 30; // Vị trí ảnh đầu tiên (từ trên xuống)
                const spacing = 15; // Khoảng cách giữa 2 ảnh
                const nextY = startY + cardHeightMM + spacing; // 103 mm
                
                // 1. Vẽ Mặt TRƯỚC (Phần 1)
                doc.addImage(croppedImage1, 'JPEG', marginX, startY, cardWidthMM, cardHeightMM);
                
                // 2. Vẽ Mặt SAU (Phần 2)
                doc.addImage(croppedImage2, 'JPEG', marginX, nextY, cardWidthMM, cardHeightMM);

                // --- THÊM CHỮ KÝ Ở GÓC DƯỚI ---
                const signatureText = "][";
                
                doc.setFont('Times', 'normal'); 
                doc.setFontSize(9); 
                const signatureMargin = 10;
                const signatureX = a4Width - signatureMargin; 
                const signatureY = a4Height - signatureMargin; 

                doc.text(signatureText, signatureX, signatureY, { align: 'right' });


                // TẠO VÀ TẢI XUỐNG PDF
                const pdfBlob = doc.output('blob');
                const url = URL.createObjectURL(pdfBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `CCCD_2Mat_A4Ngang_Chuan_${Date.now()}.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); 

                showMessage('Đã tạo file PDF A4 Ngang CCCD (2 Mặt/1 Trang Chuẩn) thành công!', 'success');

            } catch (error) {
                console.error("LỖI KHI XUẤT PDF CCCD:", error);
                showMessage(`LỖI: Không thể tạo file PDF CCCD. Chi tiết lỗi: ${error.message}. Vui lòng kiểm tra console (F12) hoặc thử lại.`, 'error');
            }
        }

        // --- LOGIC GHÉP PDF (Giữ nguyên) ---
        async function mergePdfs() {
            const files = pdfFileInput.files;
            if (files.length < 2) {
                showMergeMessage('Vui lòng chọn ít nhất 2 file PDF để ghép.', 'error');
                return;
            }

            mergePdfButton.disabled = true;
            showMergeMessage(`Đang tiến hành ghép ${files.length} file PDF... Vui lòng chờ. Quá trình này có thể mất vài phút với file lớn.`, 'info');

            try {
                const { PDFDocument } = window.PDFLib;
                const mergedPdf = await PDFDocument.create();

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // Tải file PDF vào PDFDocument
                    const pdf = await PDFDocument.load(arrayBuffer);
                    
                    // Sao chép tất cả các trang của PDF hiện tại vào PDF đích
                    const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
                    copiedPages.forEach((page) => {
                        mergedPdf.addPage(page);
                    });
                }

                const mergedPdfBytes = await mergedPdf.save();
                
                const blob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `PDF_DaGhep_${Date.now()}.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showMergeMessage(`Đã ghép thành công ${files.length} file PDF!`, 'success');

            } catch (error) {
                console.error("LỖI KHI GHÉP PDF:", error);
                showMergeMessage(`LỖI: Không thể ghép file PDF. Chi tiết lỗi: ${error.message}. Vui lòng kiểm tra console (F12) hoặc thử lại.`, 'error');
            } finally {
                mergePdfButton.disabled = false;
                pdfFileInput.value = '';
                pdfFileInput.dispatchEvent(new Event('change'));
            }
        }
        
        // --- HÀM XỬ LÝ TƯƠNG TÁC (KÉO THẢ) (Giữ nguyên) ---
        
        function getHandleAt(x, y) {
            const { x: cx, y: cy, width: cw, height: ch } = cropBox;
            const h = HANDLE_SIZE / 2;
            const handles = {
                'tl': { x: cx, y: cy },
                'tr': { x: cx + cw, y: cy },
                '
