<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xử Lý Ảnh và Ghép PDF)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script> 
    <style>
        /* Đảm bảo canvas có thể mở rộng */
        #imageCanvas {
            max-width: 100%;
            height: auto;
            border: 2px dashed #3B82F6;
            margin-top: 1rem;
            background-color: #ffffff; /* Nền trắng cho canvas */
            /* Cần thiết lập position: relative để các lớp overlay vẽ đúng */
            position: relative; 
            cursor: default;
        }
        /* Sử dụng font Inter cho thẩm mỹ */
        body {
            font-family: 'Inter', sans-serif;
            /* Thêm ảnh nền phong cảnh Việt Nam */
            background-image: url('https://cdn.pixabay.com/photo/2016/06/15/22/41/vietnam-1459891_1280.jpg');
            background-size: cover; /* Đảm bảo ảnh nền phủ kín trang */
            background-attachment: fixed; /* Giữ ảnh nền cố định khi cuộn */
            background-color: #f7f9fb; /* Màu dự phòng */
            scroll-behavior: smooth; /* Cuộn mượt khi nhấn nút */
        }
    </style>
</head>
<body>

    <div class="container mx-auto p-4 md:p-8 max-w-5xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800">Công Cụ Cắt Ghép Ảnh thành PDF</h1>
            <p class="text-gray-500 mt-2">AI Xử lý ảnh, ghép thành PDF A4 Chuẩn. Tác giả: Lê Minh Huấn CN VPĐKĐĐ 8 -SĐT: 0912041201 </p>
        </header>

        <div class="bg-white/95 p-6 rounded-xl shadow-lg border border-gray-100 mb-6">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">1. Tải và Cắt Ảnh (Chỉ hỗ trợ JPG/PNG/WEBP)</h2>
            
            <input type="file" id="fileInput" accept="image/jpeg, image/png, image/webp" style="display: none;" />
            <button id="uploadButton" class="w-full text-sm file:text-transparent
                file:mr-4 file:py-2 file:px-4 file:text-white
                file:rounded-full file:border-0 file:cursor-pointer
                file:text-sm file:font-bold file:shadow
                bg-yellow-500 hover:bg-yellow-600 transition duration-150 ease-in-out font-bold py-3 px-4 rounded-xl shadow-md text-white">
                Tải Ảnh Lên (Click vào đây)
            </button>
            
            <div id="controls" class="mt-4" style="display:none;">
                
                <div class="flex flex-wrap gap-4 mb-4">
                    <button id="autoCropButton" class="flex-1 min-w-[150px] bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Đề xuất Khung Cắt (90% Ảnh Gốc)
                    </button>
                    <button id="rotateButton" class="flex-1 min-w-[100px] bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Xoay 90°
                    </button>
                    <button id="sharpenButton" class="flex-1 min-w-[100px] bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Làm Nét Ảnh
                    </button>
                    <button id="deskewButton" class="flex-1 min-w-[100px] bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out" disabled>
                        Làm Phẳng Ảnh (Beta)
                    </button>
                    <button id="resetCropButton" class="flex-1 min-w-[100px] bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Cắt Toàn Bộ Ảnh
                    </button>
                </div>

                <div class="flex flex-wrap gap-4 mb-4">
                    <button id="savePart1Button" class="flex-1 min-w-[100px] bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Cắt & Lưu Phần 1
                    </button>
                    <button id="savePart2Button" class="flex-1 min-w-[100px] bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Cắt & Lưu Phần 2
                    </button>
                    <button id="savePart3Button" class="flex-1 min-w-[100px] bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Cắt & Lưu Phần 3
                    </button>
                    <button id="savePart4Button" class="flex-1 min-w-[100px] bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-full shadow transition duration-150 ease-in-out">
                        Cắt & Lưu Phần 4
                    </button>
                </div>
            </div>

            <div id="messageBox" class="mt-4 p-3 text-sm text-blue-700 bg-blue-100 rounded-lg hidden" role="alert"></div>

            <div class="mt-6 text-center">
                <canvas id="imageCanvas"></canvas>
            </div>

            <p class="text-sm text-gray-400 mt-4 italic text-center">Sử dụng chuột hoặc ngón tay: **Kéo** để di chuyển khung cắt. **Kéo các góc** để thay đổi kích thước.</p>
        </div>
        
        <div class="bg-white/95 p-6 rounded-xl shadow-lg border border-gray-100 mb-6">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">2. Ghép Ảnh đã cắt và Xuất PDF A4 Ngang</h2>
            <div id="pdfStatus" class="flex flex-wrap gap-4 mb-4">
                <div id="status1" class="flex-1 min-w-[200px] p-3 rounded-lg border border-red-300 bg-red-50 text-red-700">
                    Phần 1: Chưa Lưu
                </div>
                <div id="status2" class="flex-1 min-w-[200px] p-3 rounded-lg border border-red-300 bg-red-50 text-red-700">
                    Phần 2: Chưa Lưu
                </div>
                <div id="status3" class="flex-1 min-w-[200px] p-3 rounded-lg border border-red-300 bg-red-50 text-red-700">
                    Phần 3: Chưa Lưu
                </div>
                <div id="status4" class="flex-1 min-w-[200px] p-3 rounded-lg border border-red-300 bg-red-50 text-red-700">
                    Phần 4: Chưa Lưu
                </div>
            </div>
            
            <button id="createGcnPdfButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-xl shadow-md transition duration-150 ease-in-out disabled:opacity-50 mb-4" disabled>
                Tạo File PDF A4 Ngang **GCN** (Mỗi Phần/1 Trang)
            </button>
            
            <button id="createCccdPdfButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-xl shadow-md transition duration-150 ease-in-out disabled:opacity-50" disabled>
                Tạo File PDF A4 Ngang **CCCD** (Ghép 2 Mặt/1 Trang Chuẩn)
            </button>
        </div>
        
        <div class="bg-white/95 p-6 rounded-xl shadow-lg border border-gray-100 mt-6">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">3. Ghép nhiều File PDF thành 1</h2>
            <p class="text-sm text-gray-500 mb-4">Chọn **tối thiểu 2** tệp tin PDF để ghép chúng thành một file duy nhất. Tính năng này KHÔNG liên quan đến các ảnh ở phần 1 & 2.</p>
            <input type="file" id="pdfFileInput" accept="application/pdf" multiple class="w-full text-sm file:text-transparent
                file:mr-4 file:py-2 file:px-4 file:text-white
                file:rounded-full file:border-0 file:cursor-pointer
                file:text-sm file:font-bold file:shadow
                file:bg-red-500 hover:file:bg-red-600 transition duration-150 ease-in-out"
            />
            <button id="mergePdfButton" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-xl shadow-md transition duration-150 ease-in-out disabled:opacity-50 mt-4" disabled>
                Ghép N (≥ 2) File PDF Đã Chọn
            </button>
            <div id="pdfMergeMessage" class="mt-4 p-3 text-sm text-blue-700 bg-blue-100 rounded-lg hidden" role="alert"></div>
        </div>
        
    </div>

    <script>
        // --- CHỐNG XEM MÃ NGUỒN (OBFUSCATION & INTERACTION PREVENTION) ---
        document.addEventListener('contextmenu', function(e) { e.preventDefault(); console.warn("%cCẢNH BÁO: MÃ NGUỒN CÓ THỂ CHỨA THÔNG TIN ĐỘC QUYỀN. VUI LÒNG KHÔNG SAO CHÉP. Created by huanbc.", "color: red; font-size: 16px; font-weight: bold;"); });
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F12') { e.preventDefault(); console.warn("%cCẢNH BÁO: Đã vô hiệu hóa phím tắt Developer Tools (F12).", "color: red; font-size: 16px; font-weight: bold;"); }
            if ((e.ctrlKey || e.metaKey) && (e.shiftKey) && (e.key === 'I' || e.key === 'J' || e.key === 'C')) { e.preventDefault(); console.warn("%cCẢNH BÁO: Đã vô hiệu hóa phím tắt Developer Tools (Ctrl+Shift+I/J/C).", "color: red; font-size: 16px; font-weight: bold;"); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'U') { e.preventDefault(); console.warn("%cCẢNH BÁO: Đã vô hiệu hóa phím tắt View Page Source (Ctrl+U).", "color: red; font-size: 16px; font-weight: bold;"); }
        });

        // Khai báo các biến toàn cục (CẮT ẢNH)
        const fileInput = document.getElementById('fileInput');
        const uploadButton = document.getElementById('uploadButton'); 
        const rotateButton = document.getElementById('rotateButton');
        const autoCropButton = document.getElementById('autoCropButton');
        const resetCropButton = document.getElementById('resetCropButton');
        const sharpenButton = document.getElementById('sharpenButton'); // THÊM
        const deskewButton = document.getElementById('deskewButton');   // THÊM
        const savePart1Button = document.getElementById('savePart1Button');
        const savePart2Button = document.getElementById('savePart2Button');
        const savePart3Button = document.getElementById('savePart3Button');
        const savePart4Button = document.getElementById('savePart4Button');
        // Thay thế createPdfButton bằng 2 nút mới
        const createGcnPdfButton = document.getElementById('createGcnPdfButton');
        const createCccdPdfButton = document.getElementById('createCccdPdfButton');
        
        const controls = document.getElementById('controls');
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const status1 = document.getElementById('status1');
        const status2 = document.getElementById('status2');
        const status3 = document.getElementById('status3');
        const status4 = document.getElementById('status4');
        
        let originalImage = null;       
        let rotationAngle = 0;          
        let croppedImage1 = null; 
        let croppedImage2 = null;  
        let croppedImage3 = null;  
        let croppedImage4 = null;  

        let cropBox = { x: 0, y: 0, width: 0, height: 0 };
        const HANDLE_SIZE = 15; 
        let isDragging = false;
        let dragHandle = null; 
        let startX, startY; 
        let cropStart;      

        // Khai báo các biến toàn cục (GHÉP PDF)
        const pdfFileInput = document.getElementById('pdfFileInput');
        const mergePdfButton = document.getElementById('mergePdfButton');
        const pdfMergeMessage = document.getElementById('pdfMergeMessage'); 


        // --- HÀM HỖ TRỢ CHUNG (CẮT ẢNH) ---

        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.className = 'mt-4 p-3 text-sm rounded-lg';
            messageBox.classList.remove('hidden');

            switch (type) {
                case 'error':
                    messageBox.classList.add('text-red-700', 'bg-red-100', 'border-red-300');
                    break;
                case 'success':
                    messageBox.classList.add('text-green-700', 'bg-green-100', 'border-green-300');
                    break;
                case 'info':
                default:
                    messageBox.classList.add('text-blue-700', 'bg-blue-100', 'border-blue-300');
                    break;
            }
        }
        
        function updateStatus() {
            const statuses = [
                { index: 1, element: status1, image: croppedImage1 },
                { index: 2, element: status2, image: croppedImage2 },
                { index: 3, element: status3, image: croppedImage3 },
                { index: 4, element: status4, image: croppedImage4 },
            ];
            let gcnReady = false;
            let cccdReady = false;

            statuses.forEach(s => {
                if (s.image) {
                    s.element.textContent = `Phần ${s.index}: Đã Lưu`;
                    s.element.className = 'flex-1 min-w-[200px] p-3 rounded-lg border border-green-300 bg-green-50 text-green-700';
                    gcnReady = true; // Chỉ cần 1 phần là GCN đã sẵn sàng
                } else {
                    s.element.textContent = `Phần ${s.index}: Chưa Lưu`;
                    s.element.className = 'flex-1 min-w-[200px] p-3 rounded-lg border border-red-300 bg-red-50 text-red-700';
                }
            });
            
            // CCCD chỉ sẵn sàng nếu Phần 1 VÀ Phần 2 đã được lưu
            if (croppedImage1 && croppedImage2) {
                cccdReady = true;
            }

            createGcnPdfButton.disabled = !gcnReady;
            createCccdPdfButton.disabled = !cccdReady;
        }
        
        // --- HÀM HỖ TRỢ CHUNG (GHÉP PDF) ---
        function showMergeMessage(message, type = 'info') {
            pdfMergeMessage.textContent = message;
            pdfMergeMessage.className = 'mt-4 p-3 text-sm rounded-lg';
            pdfMergeMessage.classList.remove('hidden');

            switch (type) {
                case 'error':
                    pdfMergeMessage.classList.add('text-red-700', 'bg-red-100', 'border-red-300');
                    break;
                case 'success':
                    pdfMergeMessage.classList.add('text-green-700', 'bg-green-100', 'border-green-300');
                    break;
                case 'info':
                default:
                    pdfMergeMessage.classList.add('text-blue-700', 'bg-blue-100', 'border-blue-300');
                    break;
            }
        }

        // --- HÀM XỬ LÝ ẢNH & CANVAS ---

        function drawImage() {
            if (!originalImage) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const rotation = rotationAngle % 360;
            const isRotated = rotation === 90 || rotation === 270;

            const canvasWidth = isRotated ? originalImage.height : originalImage.width;
            const canvasHeight = isRotated ? originalImage.width : originalImage.height;

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            ctx.save();
            ctx.translate(canvasWidth / 2, canvasHeight / 2);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);
            ctx.restore();

            drawCropOverlay(canvasWidth, canvasHeight);
        }

        function drawCropOverlay(currentCanvasWidth, currentCanvasHeight) {
            const { x, y, width, height } = cropBox;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            
            ctx.fillRect(0, 0, currentCanvasWidth, y);
            ctx.fillRect(0, y + height, currentCanvasWidth, currentCanvasHeight - (y + height));
            ctx.fillRect(0, y, x, height);
            ctx.fillRect(x + width, y, currentCanvasWidth - (x + width), height);

            ctx.strokeStyle = '#22C55E'; 
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]); 
            ctx.strokeRect(x, y, width, height);
            ctx.setLineDash([]); 

            ctx.fillStyle = '#22C55E';
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;

            const handles = [
                { x: x, y: y, cursor: 'nwse-resize' },                   
                { x: x + width, y: y, cursor: 'nesw-resize' },           
                { x: x, y: y + height, cursor: 'nesw-resize' },          
                { x: x + width, y: y + height, cursor: 'nwse-resize' }   
            ];

            handles.forEach(h => {
                ctx.beginPath();
                ctx.arc(h.x, h.y, HANDLE_SIZE / 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            });
        }
        
        function cropImage() {
            if (!originalImage || cropBox.width <= 0 || cropBox.height <= 0) return null;

            const sourceX = cropBox.x;
            const sourceY = cropBox.y;
            const cropWidth = cropBox.width;
            const cropHeight = cropBox.height;
            
            const rotation = rotationAngle % 360;
            const isRotated = rotation === 90 || rotation === 270;
            const rotatedWidth = isRotated ? originalImage.height : originalImage.width;
            const rotatedHeight = isRotated ? originalImage.width : originalImage.height;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = rotatedWidth;
            tempCanvas.height = rotatedHeight;

            tempCtx.save();
            tempCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
            tempCtx.rotate(rotation * Math.PI / 180);
            tempCtx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);
            tempCtx.restore();

            const finalCanvas = document.createElement('canvas');
            const finalCtx = finalCanvas.getContext('2d');
            finalCanvas.width = cropWidth;
            finalCanvas.height = cropHeight;

            try {
                const imageData = tempCtx.getImageData(sourceX, sourceY, cropWidth, cropHeight);
                finalCtx.putImageData(imageData, 0, 0);
            } catch (error) {
                console.error("Lỗi khi lấy/đặt dữ liệu ảnh:", error);
                return null;
            }

            return finalCanvas.toDataURL('image/jpeg', 0.95);
        }

        // --- HÀM LÀM NÉT ẢNH (SHARPEN) ---
        
        // Hàm tiện ích: Áp dụng bộ lọc Convolution
        function applyConvolutionFilter(pixels, weights) {
            const side = Math.round(Math.sqrt(weights.length));
            const halfSide = Math.floor(side / 2);
            const src = pixels.data;
            const sw = pixels.width;
            const sh = pixels.height;
            const output = ctx.createImageData(sw, sh);
            const dst = output.data;
            const alphaFac = 1;

            // Lặp qua từng pixel (không tính viền)
            for (let y = halfSide; y < sh - halfSide; y++) {
                for (let x = halfSide; x < sw - halfSide; x++) {
                    const dstIndex = (y * sw + x) * 4;
                    let r = 0, g = 0, b = 0;

                    for (let cy = 0; cy < side; cy++) {
                        for (let cx = 0; cx < side; cx++) {
                            const scx = x + cx - halfSide;
                            const scy = y + cy - halfSide;
                            const srcIndex = (scy * sw + scx) * 4;
                            
                            const weight = weights[cy * side + cx];
                            
                            r += src[srcIndex] * weight;
                            g += src[srcIndex + 1] * weight;
                            b += src[srcIndex + 2] * weight;
                        }
                    }

                    dst[dstIndex] = Math.min(255, Math.max(0, r));
                    dst[dstIndex + 1] = Math.min(255, Math.max(0, g));
                    dst[dstIndex + 2] = Math.min(255, Math.max(0, b));
                    dst[dstIndex + 3] = src[dstIndex + 3] * alphaFac;
                }
            }
            return output;
        }

        // Hàm xử lý: Làm nét ảnh
        function sharpenImage() {
            if (!originalImage) { showMessage('Vui lòng tải ảnh lên trước.', 'error'); return; }

            try {
                showMessage('Đang xử lý làm nét ảnh... Vui lòng chờ.', 'info');

                // Tạm thời vẽ lại ảnh lên canvas với kích thước chính xác của ảnh đã xoay
                const rotation = rotationAngle % 360;
                const isRotated = rotation === 90 || rotation === 270;
                const rotatedWidth = isRotated ? originalImage.height : originalImage.width;
                const rotatedHeight = isRotated ? originalImage.width : originalImage.height;

                canvas.width = rotatedWidth;
                canvas.height = rotatedHeight;
                ctx.save();
                ctx.translate(rotatedWidth / 2, rotatedHeight / 2);
                ctx.rotate(rotation * Math.PI / 180);
                ctx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);
                ctx.restore();

                // 1. Lấy dữ liệu pixel
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // 2. Định nghĩa Kernel Làm Nét (Sharpening Kernel)
                const sharpenWeights = [
                    0, -1, 0,
                    -1, 5, -1,
                    0, -1, 0
                ];
                
                // 3. Áp dụng bộ lọc
                const sharpenedData = applyConvolutionFilter(imageData, sharpenWeights);
                
                // 4. Ghi dữ liệu pixel đã xử lý trở lại canvas
                ctx.putImageData(sharpenedData, 0, 0);

                // Cập nhật originalImage để lưu trữ trạng thái mới của ảnh
                const newImage = new Image();
                newImage.onload = () => {
                    originalImage = newImage;
                    rotationAngle = 0; // Đặt lại góc xoay vì ảnh mới đã được xoay và vẽ phẳng lên canvas
                    initCropBox();
                    drawImage(); // Vẽ lại để cập nhật overlay
                    showMessage('Đã áp dụng bộ lọc Làm Nét Ảnh thành công!', 'success');
                };
                newImage.src = canvas.toDataURL('image/jpeg', 0.95);
                
            } catch (error) {
                console.error("LỖI KHI LÀM NÉT ẢNH:", error);
                showMessage(`LỖI: Không thể làm nét ảnh. Chi tiết lỗi: ${error.message}.`, 'error');
            }
        }
        
        /**
         * Chế độ GCN: Xuất mỗi ảnh đã cắt ra một trang PDF A4 Ngang riêng biệt, co giãn để vừa chiều rộng.
         */
        function createGcnPdfFromMultipleImages() {
            const imagesData = [croppedImage1, croppedImage2, croppedImage3, croppedImage4];
            const images = imagesData.filter(img => img !== null);
            
            if (images.length === 0) {
                showMessage('Vui lòng cắt và lưu ít nhất một Phần ảnh trước khi tạo PDF.', 'error');
                return;
            }
            
            try {
                // Khởi tạo jsPDF với kích thước A4 (Landscape - Ngang, đơn vị mm)
                const doc = new window.jspdf.jsPDF('l', 'mm', 'a4');
                
                const a4Width = 297; // Chiều rộng A4 Ngang
                const a4Height = 210; // Chiều cao A4 Ngang
                const margin = 10;
                const usableWidth = a4Width - 2 * margin; 
                
                // Lặp qua từng ảnh đã cắt
                images.forEach((imgDataUrl, index) => {
                    // Thêm trang mới TỪ trang thứ hai trở đi
                    if (index > 0) {
                        doc.addPage();
                    }
                    
                    const img = document.createElement('img');
                    img.src = imgDataUrl;
                    
                    const imgWidthPx = img.width || 1000; 
                    const imgHeightPx = img.height || 600; 
                    
                    const aspectRatio = imgWidthPx / imgHeightPx;
                    
                    const imageWidthMM = usableWidth; 
                    const imageHeightMM = imageWidthMM / aspectRatio;

                    // Căn giữa theo chiều cao
                    const startY = (a4Height - imageHeightMM) / 2;

                    doc.addImage(imgDataUrl, 'JPEG', margin, startY, imageWidthMM, imageHeightMM);
                });

                const signatureText = "][";
                doc.setFont('Times', 'normal'); 
                doc.setFontSize(9); 
                const signatureMargin = 10;
                const signatureX = a4Width - signatureMargin; 
                const signatureY = a4Height - signatureMargin; 

                doc.setPage(doc.internal.pages.length);
                doc.text(signatureText, signatureX, signatureY, { align: 'right' });


                const pdfBlob = doc.output('blob');
                const url = URL.createObjectURL(pdfBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `GCN_MoiPhan1Trang_A4Ngang_${Date.now()}.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); 

                showMessage(`Đã tạo file PDF A4 Ngang thành công! Gồm ${images.length} trang.`, 'success');

            } catch (error) {
                console.error("LỖI KHI XUẤT PDF GCN:", error);
                showMessage(`LỖI: Không thể tạo file PDF GCN. Chi tiết lỗi: ${error.message}. Vui lòng kiểm tra console (F12) hoặc thử lại.`, 'error');
            }
        }

        /**
         * Chế độ CCCD: Ghép ảnh Phần 1 & Phần 2 vào 1 trang PDF A4 Ngang với kích thước chuẩn.
         */
        function createCccdPdfFromTwoImages() {
            if (!croppedImage1 || !croppedImage2) {
                showMessage('Vui lòng cắt và lưu cả Phần 1 và Phần 2 để ghép CCCD (2 Mặt).', 'error');
                return;
            }
            
            try {
                // Khởi tạo jsPDF với kích thước A4 (Landscape - Ngang, đơn vị mm)
                const doc = new window.jspdf.jsPDF('l', 'mm', 'a4');
                
                const a4Width = 297; // Chiều rộng A4 Ngang
                const a4Height = 210; // Chiều cao A4 Ngang
                // Kích thước CCCD chuẩn (mm): 87 x 58
                const cardWidthMM = 87;
                const cardHeightMM = 58;

                // Tính toán vị trí ảnh (Căn giữa ngang)
                const marginX = (a4Width - cardWidthMM) / 2; // 105 mm
                const startY = 30; // Vị trí ảnh đầu tiên (từ trên xuống)
                const spacing = 15; // Khoảng cách giữa 2 ảnh
                const nextY = startY + cardHeightMM + spacing; // 103 mm
                
                // 1. Vẽ Mặt TRƯỚC (Phần 1)
                doc.addImage(croppedImage1, 'JPEG', marginX, startY, cardWidthMM, cardHeightMM);
                
                // 2. Vẽ Mặt SAU (Phần 2)
                doc.addImage(croppedImage2, 'JPEG', marginX, nextY, cardWidthMM, cardHeightMM);

                // --- THÊM CHỮ KÝ Ở GÓC DƯỚI ---
                const signatureText = "][";
                
                doc.setFont('Times', 'normal'); 
                doc.setFontSize(9); 
                const signatureMargin = 10;
                const signatureX = a4Width - signatureMargin; 
                const signatureY = a4Height - signatureMargin; 

                doc.text(signatureText, signatureX, signatureY, { align: 'right' });


                // TẠO VÀ TẢI XUỐNG PDF
                const pdfBlob = doc.output('blob');
                const url = URL.createObjectURL(pdfBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `CCCD_2Mat_A4Ngang_Chuan_${Date.now()}.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); 

                showMessage('Đã tạo file PDF A4 Ngang CCCD (2 Mặt/1 Trang Chuẩn) thành công!', 'success');

            } catch (error) {
                console.error("LỖI KHI XUẤT PDF CCCD:", error);
                showMessage(`LỖI: Không thể tạo file PDF CCCD. Chi tiết lỗi: ${error.message}. Vui lòng kiểm tra console (F12) hoặc thử lại.`, 'error');
            }
        }

        // --- LOGIC GHÉP PDF ---

        async function mergePdfs() {
            const files = pdfFileInput.files;
            if (files.length < 2) {
                showMergeMessage('Vui lòng chọn ít nhất 2 file PDF để ghép.', 'error');
                return;
            }

            mergePdfButton.disabled = true;
            showMergeMessage(`Đang tiến hành ghép ${files.length} file PDF... Vui lòng chờ. Quá trình này có thể mất vài phút với file lớn.`, 'info');

            try {
                const { PDFDocument } = window.PDFLib;
                const mergedPdf = await PDFDocument.create();

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // Tải file PDF vào PDFDocument
                    const pdf = await PDFDocument.load(arrayBuffer);
                    
                    // Sao chép tất cả các trang của PDF hiện tại vào PDF đích
                    const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
                    copiedPages.forEach((page) => {
                        mergedPdf.addPage(page);
                    });
                }

                const mergedPdfBytes = await mergedPdf.save();
                
                const blob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `PDF_DaGhep_${Date.now()}.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showMergeMessage(`Đã ghép thành công ${files.length} file PDF!`, 'success');

            } catch (error) {
                console.error("LỖI KHI GHÉP PDF:", error);
                showMergeMessage(`LỖI: Không thể ghép file PDF. Chi tiết lỗi: ${error.message}. Vui lòng kiểm tra console (F12) hoặc thử lại.`, 'error');
            } finally {
                mergePdfButton.disabled = false;
                pdfFileInput.value = '';
                pdfFileInput.dispatchEvent(new Event('change'));
            }
        }

        // --- HÀM XỬ LÝ TƯƠNG TÁC (KÉO THẢ) (Giữ nguyên) ---
        
        function getHandleAt(x, y) {
            const { x: cx, y: cy, width: cw, height: ch } = cropBox;
            const h = HANDLE_SIZE / 2;
            const handles = {
                'tl': { x: cx, y: cy },
                'tr': { x: cx + cw, y: cy },
                'bl': { x: cx, y: cy + ch },
                'br': { x: cx + cw, y: cy + ch },
            };
            for (const key in handles) {
                const handle = handles[key];
                if (x >= handle.x - h && x <= handle.x + h && y >= handle.y - h && y <= handle.y + h) {
                    return key;
                }
            }
            if (x >= cx + h && x <= cx + cw - h && y >= cy + h && y <= cy + ch - h) {
                return 'move';
            }
            return null;
        }

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function handleMouseDown(e) {
            if (!originalImage) return;
            const pos = getMousePos(e);
            dragHandle = getHandleAt(pos.x, pos.y);
            if (dragHandle) {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                startX = pos.x;
                startY = pos.y;
                cropStart = { ...cropBox };
            }
        }

        function handleMouseMove(e) {
            if (!isDragging || !originalImage) return;
            e.preventDefault();
            e.stopPropagation();
            const pos = getMousePos(e);
            const dx = pos.x - startX;
            const dy = pos.y - startY;
            updateCropBox(dx, dy);
            drawImage();
        }

        function handleMouseUp() {
            if (isDragging) {
                isDragging = false;
                dragHandle = null;
                showMessage(`Đã tùy chỉnh khung cắt. X: ${Math.round(cropBox.x)}, Y: ${Math.round(cropBox.y)}, W: ${Math.round(cropBox.width)}, H: ${Math.round(cropBox.height)}`, 'info');
            }
        }

        function getTouchPos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const touch = evt.touches[0];
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        function handleTouchStart(e) {
            if (!originalImage) return;
            const pos = getTouchPos(e);
            dragHandle = getHandleAt(pos.x, pos.y);
            if (dragHandle) {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                startX = pos.x;
                startY = pos.y;
                cropStart = { ...cropBox };
            }
        }

        function handleTouchMove(e) {
            if (!isDragging || !originalImage) return;
            e.preventDefault();
            e.stopPropagation();
            
            const pos = getTouchPos(e);
            const dx = pos.x - startX;
            const dy = pos.y - startY;

            updateCropBox(dx, dy);
            drawImage();
        }

        function handleTouchEnd() {
            if (isDragging) {
                isDragging = false;
                dragHandle = null;
                showMessage(`Đã tùy chỉnh khung cắt. X: ${Math.round(cropBox.x)}, Y: ${Math.round(cropBox.y)}, W: ${Math.round(cropBox.width)}, H: ${Math.round(cropBox.height)}`, 'info');
            }
        }

        function updateCropBox(dx, dy) {
            const { x: cx, y: cy, width: cw, height: ch } = cropStart;
            const canvasW = canvas.width;
            const canvasH = canvas.height;
            let newX = cx, newY = cy, newW = cw, newH = ch;

            if (dragHandle === 'move') {
                newX = Math.min(Math.max(0, cx + dx), canvasW - cw);
                newY = Math.min(Math.max(0, cy + dy), canvasH - ch);
            } else if (dragHandle) {
                switch (dragHandle) {
                    case 'tl':
                        newX = Math.min(cx + dx, cx + cw - 50); 
                        newY = Math.min(cy + dy, cy + ch - 50);
                        newW = cw - (newX - cx);
                        newH = ch - (newY - cy);
                        break;
                    case 'tr':
                        newW = Math.max(50, cw + dx); 
                        newY = Math.min(cy + dy, cy + ch - 50);
                        newH = ch - (newY - cy);
                        break;
                    case 'bl':
                        newX = Math.min(cx + dx, cx + cw - 50);
                        newW = cw - (newX - cx);
                        newH = Math.max(50, ch + dy);
                        break;
                    case 'br':
                        newW = Math.max(50, cw + dx);
                        newH = Math.max(50, ch + dy);
                        break;
                }
            }

            newX = Math.max(0, newX);
            newY = Math.max(0, newY);
            newW = Math.min(canvasW - newX, newW);
            newH = Math.min(canvasH - newY, newH);

            cropBox.x = newX;
            cropBox.y = newY;
            cropBox.width = newW;
            cropBox.height = newH;
        }

        // --- EVENT LISTENERS KHỞI TẠO ---

        function initCropBox(box = null) {
            const w = canvas.width;
            const h = canvas.height;

            if (box) {
                cropBox.x = box.x;
                cropBox.y = box.y;
                cropBox.width = box.width;
                cropBox.height = box.height;
            } else {
                cropBox.x = 0;
                cropBox.y = 0;
                cropBox.width = w;
                cropBox.height = h;
            }
        }

        // Kích hoạt input file khi nhấn nút Upload
        uploadButton.addEventListener('click', () => {
            fileInput.click();
        });

        // Event tải file ảnh 
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            
            reader.onerror = (err) => {
                 console.error("[ERROR] Lỗi khi đọc tệp bằng FileReader:", err);
                 showMessage(`Lỗi hệ thống: Không thể đọc tệp (${file.name}). Vui lòng kiểm tra Console (F12) để biết chi tiết.`, 'error');
            }

            reader.onload = (event) => {
                originalImage = new Image();
                
                originalImage.onerror = (err) => {
                     console.error("[ERROR] Lỗi khi gán DataURL vào Image (Image.onerror fired). Image không hợp lệ hoặc quá lớn.", err);
                     showMessage(`Lỗi: Không thể hiển thị tệp tin (${file.name}). Tệp ảnh có thể bị lỗi, không phải định dạng JPG/PNG chuẩn, hoặc quá lớn. Vui lòng kiểm tra Console (F12).`, 'error');
                     controls.style.display = 'none';
                     originalImage = null;
                     ctx.clearRect(0, 0, canvas.width, canvas.height);
                }

                originalImage.onload = () => {
                    rotationAngle = 0; 
                    
                    controls.style.display = 'block'; 
                    
                    drawImage(); 
                    initCropBox();
                    drawImage(); 
                    showMessage(`Ảnh đã được tải (${file.name}). Sử dụng chuột để kéo thả khung cắt.`, 'success');
                    
                    canvas.scrollIntoView({ behavior: 'smooth', block: 'center' });
                };
                
                originalImage.src = event.target.result;
            };
            
            reader.readAsDataURL(file);
        });

        // Event xoay ảnh
        rotateButton.addEventListener('click', () => {
            if (!originalImage) { showMessage('Vui lòng tải ảnh lên trước.', 'error'); return; }
            rotationAngle = (rotationAngle + 90) % 360;
            drawImage();
            initCropBox(); 
            drawImage();
            showMessage(`Đã xoay ảnh 90°. Góc xoay hiện tại: ${rotationAngle}°`, 'info');
        });

        // Event làm nét ảnh
        sharpenButton.addEventListener('click', sharpenImage);

        // Event làm phẳng ảnh (Deskew)
        deskewButton.addEventListener('click', () => {
            showMessage('Tính năng "Làm Phẳng Ảnh" đang trong giai đoạn phát triển (Beta) do yêu cầu thư viện Computer Vision phức tạp (như OpenCV.js).', 'info');
        });
        
        // Event tự động cắt
        autoCropButton.addEventListener('click', () => {
            if (!originalImage) { showMessage('Vui lòng tải ảnh lên trước.', 'error'); return; }
            const canvasW = canvas.width;
            const canvasH = canvas.height;
            const newCropWidth = canvasW * 0.9;
            const newCropHeight = canvasH * 0.9;
            const newX = (canvasW - newCropWidth) / 2;
            const newY = (canvasH - newCropHeight) / 2;
            const newCropBox = { x: newX, y: newY, width: newCropWidth, height: newCropHeight };
            initCropBox(newCropBox);
            drawImage();
            showMessage('Đã đặt khung cắt mặc định 90% kích thước ảnh. Bạn có thể kéo thả để tinh chỉnh.', 'success');
        });

        // Event reset khung cắt
        resetCropButton.addEventListener('click', () => {
            if (!originalImage) return;
            initCropBox();
            drawImage();
            showMessage('Khung cắt đã được đặt lại là toàn bộ ảnh. Bạn có thể kéo thả để vẽ khung mới.', 'info');
        });

        // --- CÁC HÀM LƯU PHẦN 1 ĐẾN PHẦN 4 ---
        savePart1Button.addEventListener('click', () => {
            const resultDataUrl = cropImage();
            if (resultDataUrl) { croppedImage1 = resultDataUrl; updateStatus(); showMessage('Đã Cắt và Lưu ảnh Phần 1!', 'success'); } else { showMessage('Lỗi khi cắt ảnh. Vui lòng tải ảnh lên lại.', 'error'); }
        });

        savePart2Button.addEventListener('click', () => {
            const resultDataUrl = cropImage();
            if (resultDataUrl) { croppedImage2 = resultDataUrl; updateStatus(); showMessage('Đã Cắt và Lưu ảnh Phần 2!', 'success'); } else { showMessage('Lỗi khi cắt ảnh. Vui lòng tải ảnh lên lại.', 'error'); }
        });
        
        savePart3Button.addEventListener('click', () => {
            const resultDataUrl = cropImage();
            if (resultDataUrl) { croppedImage3 = resultDataUrl; updateStatus(); showMessage('Đã Cắt và Lưu ảnh Phần 3!', 'success'); } else { showMessage('Lỗi khi cắt ảnh. Vui lòng tải ảnh lên lại.', 'error'); }
        });

        savePart4Button.addEventListener('click', () => {
            const resultDataUrl = cropImage();
            if (resultDataUrl) { croppedImage4 = resultDataUrl; updateStatus(); showMessage('Đã Cắt và Lưu ảnh Phần 4!', 'success'); } else { showMessage('Lỗi khi cắt ảnh. Vui lòng tải ảnh lên lại.', 'error'); }
        });
        
        // --- EVENT LISTENERS CHO TẠO PDF ---
        createGcnPdfButton.addEventListener('click', createGcnPdfFromMultipleImages);
        createCccdPdfButton.addEventListener('click', createCccdPdfFromTwoImages);

        // --- EVENT LISTENERS CHO TÍNH NĂNG GHÉP PDF ---
        pdfFileInput.addEventListener('change', () => {
            const fileCount = pdfFileInput.files.length;
            if (fileCount >= 2) {
                mergePdfButton.disabled = false;
                showMergeMessage(`Đã chọn ${fileCount} file PDF. Sẵn sàng để ghép.`, 'info');
            } else {
                mergePdfButton.disabled = true;
                showMergeMessage('Vui lòng chọn ít nhất 2 file PDF để kích hoạt nút ghép.', 'info');
            }
        });
        
        mergePdfButton.addEventListener('click', mergePdfs);

        // Đăng ký sự kiện chuột và chạm cho tương tác kéo thả (CẮT ẢNH)
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);


        // Khởi tạo trạng thái ban đầu
        updateStatus(); 
        showMergeMessage('Chọn các file PDF bạn muốn ghép lại thành một file duy nhất.', 'info');
    </script>
</body>
</html>
